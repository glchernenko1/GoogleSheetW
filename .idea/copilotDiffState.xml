<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/internal/app/app.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/app/app.go" />
              <option name="originalContent" value="package app&#10;&#10;import (&#10;&#9;&quot;GoogleSheetW/internal/cache/localCache&quot;&#10;&#9;&quot;GoogleSheetW/internal/config&quot;&#10;&#9;&quot;GoogleSheetW/internal/controller&quot;&#10;&#9;&quot;GoogleSheetW/internal/logger&quot;&#10;&#9;&quot;GoogleSheetW/internal/services/sheetsControl&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;go.uber.org/zap&quot;&#10;&#9;&quot;net/http&quot;&#10;)&#10;&#10;type App struct {&#10;&#9;config        *config.Config&#10;&#9;log           *zap.SugaredLogger&#10;&#9;sheetsControl *sheetsControl.SheetsControl&#10;&#9;controller    *controller.SheetsController&#10;}&#10;&#10;func New() *App {&#10;&#9;cfg := config.GetConfig()&#10;&#9;log := logger.Get()&#10;&#10;&#9;// Инициализация кэша&#10;&#9;cache := localCache.GetInstance()&#10;&#10;&#9;// Инициализация сервиса для работы с Google Sheets&#10;&#9;ctx := context.Background()&#10;&#9;sheetsCtrl := sheetsControl.New(ctx, cache, &quot;google.json&quot;)&#10;&#10;&#9;// Инициализация HTTP контроллера&#10;&#9;httpController := controller.NewSheetsController(sheetsCtrl)&#10;&#10;&#9;return &amp;App{&#10;&#9;&#9;config:        cfg,&#10;&#9;&#9;log:           log,&#10;&#9;&#9;sheetsControl: sheetsCtrl,&#10;&#9;&#9;controller:    httpController,&#10;&#9;}&#10;}&#10;&#10;func (a *App) setupRoutes() *http.ServeMux {&#10;&#9;mux := http.NewServeMux()&#10;&#10;&#9;// Роуты для API&#10;&#9;mux.HandleFunc(&quot;/api/sheets/set-data&quot;, a.controller.SetSheetData)&#10;&#9;mux.HandleFunc(&quot;/api/sheets/delete-sheet&quot;, a.controller.DeleteSheet)&#10;&#9;mux.HandleFunc(&quot;/api/sheets/delete-spreadsheet&quot;, a.controller.DeleteSpreadsheet)&#10;&#10;&#9;// Добавим простой health check endpoint&#10;&#9;mux.HandleFunc(&quot;/health&quot;, func(w http.ResponseWriter, r *http.Request) {&#10;&#9;&#9;w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;&#9;&#9;w.WriteHeader(http.StatusOK)&#10;&#9;&#9;if _, err := w.Write([]byte(`{&quot;status&quot;: &quot;ok&quot;}`)); err != nil {&#10;&#9;&#9;&#9;a.log.Errorw(&quot;Ошибка записи ответа health check&quot;, &quot;error&quot;, err)&#10;&#9;&#9;}&#10;&#9;})&#10;&#10;&#9;return mux&#10;}&#10;&#10;func (a *App) Run() error {&#10;&#9;mux := a.setupRoutes()&#10;&#10;&#9;addr := fmt.Sprintf(&quot;:%d&quot;, a.config.App.Port)&#10;&#9;a.log.Infow(&quot;Сервер запускается&quot;, &quot;address&quot;, addr)&#10;&#10;&#9;server := &amp;http.Server{&#10;&#9;&#9;Addr:    addr,&#10;&#9;&#9;Handler: mux,&#10;&#9;}&#10;&#10;&#9;a.log.Info(&quot;API endpoints:&quot;)&#10;&#9;a.log.Info(&quot;POST /api/sheets/set-data - установка данных в таблицу&quot;)&#10;&#9;a.log.Info(&quot;DELETE /api/sheets/delete-sheet - удаление листа из таблицы&quot;)&#10;&#9;a.log.Info(&quot;DELETE /api/sheets/delete-spreadsheet - удаление всей таблицы&quot;)&#10;&#9;a.log.Info(&quot;GET /health - проверка состояния сервиса&quot;)&#10;&#10;&#9;return server.ListenAndServe()&#10;}&#10;" />
              <option name="updatedContent" value="package app&#10;&#10;import (&#10;&#9;&quot;GoogleSheetW/internal/cache/localCache&quot;&#10;&#9;&quot;GoogleSheetW/internal/config&quot;&#10;&#9;&quot;GoogleSheetW/internal/controller&quot;&#10;&#9;&quot;GoogleSheetW/internal/logger&quot;&#10;&#9;&quot;GoogleSheetW/internal/services/sheetsControl&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;go.uber.org/zap&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type App struct {&#10;&#9;config        *config.Config&#10;&#9;log           *zap.SugaredLogger&#10;&#9;sheetsControl *sheetsControl.SheetsControl&#10;&#9;controller    *controller.SheetsController&#10;}&#10;&#10;func New() *App {&#10;&#9;cfg := config.GetConfig()&#10;&#9;log := logger.Get()&#10;&#10;&#9;// Инициализация кэша&#10;&#9;cache := localCache.GetInstance()&#10;&#10;&#9;// Инициализация сервиса для работы с Google Sheets&#10;&#9;ctx := context.Background()&#10;&#9;sheetsCtrl := sheetsControl.New(ctx, cache, &quot;google.json&quot;)&#10;&#10;&#9;// Инициализация HTTP контроллера&#10;&#9;httpController := controller.NewSheetsController(sheetsCtrl)&#10;&#10;&#9;return &amp;App{&#10;&#9;&#9;config:        cfg,&#10;&#9;&#9;log:           log,&#10;&#9;&#9;sheetsControl: sheetsCtrl,&#10;&#9;&#9;controller:    httpController,&#10;&#9;}&#10;}&#10;&#10;func (a *App) setupRoutes() *http.ServeMux {&#10;&#9;mux := http.NewServeMux()&#10;&#10;&#9;// Роуты для API&#10;&#9;mux.HandleFunc(&quot;/api/sheets/set-data&quot;, a.controller.SetSheetData)&#10;&#9;mux.HandleFunc(&quot;/api/sheets/&quot;, a.handleSheetsRequests) // Универсальный обработчик для DELETE запросов&#10;&#10;&#9;// Добавим простой health check endpoint&#10;&#9;mux.HandleFunc(&quot;/health&quot;, func(w http.ResponseWriter, r *http.Request) {&#10;&#9;&#9;w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;&#9;&#9;w.WriteHeader(http.StatusOK)&#10;&#9;&#9;if _, err := w.Write([]byte(`{&quot;status&quot;: &quot;ok&quot;}`)); err != nil {&#10;&#9;&#9;&#9;a.log.Errorw(&quot;Ошибка записи ответа health check&quot;, &quot;error&quot;, err)&#10;&#9;&#9;}&#10;&#9;})&#10;&#10;&#9;return mux&#10;}&#10;&#10;// handleSheetsRequests универсальный обработчик для маршрутизации запросов к таблицам&#10;func (a *App) handleSheetsRequests(w http.ResponseWriter, r *http.Request) {&#10;&#9;// Только DELETE запросы обрабатываем здесь&#10;&#9;if r.Method != http.MethodDelete {&#10;&#9;&#9;http.Error(w, &quot;Метод не разрешен&quot;, http.StatusMethodNotAllowed)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Удаляем префикс /api/sheets/ и анализируем путь&#10;&#9;path := r.URL.Path[len(&quot;/api/sheets/&quot;):]&#10;&#10;&#9;if path == &quot;&quot; {&#10;&#9;&#9;http.Error(w, &quot;Неверный URL&quot;, http.StatusBadRequest)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Проверяем структуру пути&#10;&#9;parts := strings.Split(path, &quot;/&quot;)&#10;&#10;&#9;if len(parts) == 1 &amp;&amp; parts[0] != &quot;&quot; {&#10;&#9;&#9;// DELETE /api/sheets/{fiat} - удаление всей таблицы&#10;&#9;&#9;a.controller.DeleteSpreadsheet(w, r)&#10;&#9;} else if len(parts) == 3 &amp;&amp; parts[1] == &quot;sheet&quot; &amp;&amp; parts[2] != &quot;&quot; {&#10;&#9;&#9;// DELETE /api/sheets/{fiat}/sheet/{sheetName} - удаление листа&#10;&#9;&#9;a.controller.DeleteSheet(w, r)&#10;&#9;} else {&#10;&#9;&#9;http.Error(w, &quot;Неверный формат URL&quot;, http.StatusBadRequest)&#10;&#9;&#9;return&#10;&#9;}&#10;}&#10;&#10;func (a *App) Run() error {&#10;&#9;mux := a.setupRoutes()&#10;&#10;&#9;addr := fmt.Sprintf(&quot;:%d&quot;, a.config.App.Port)&#10;&#9;a.log.Infow(&quot;Сервер запускается&quot;, &quot;address&quot;, addr)&#10;&#10;&#9;server := &amp;http.Server{&#10;&#9;&#9;Addr:    addr,&#10;&#9;&#9;Handler: mux,&#10;&#9;}&#10;&#10;&#9;a.log.Info(&quot;API endpoints:&quot;)&#10;&#9;a.log.Info(&quot;POST /api/sheets/set-data - установка данных в таблицу&quot;)&#10;&#9;a.log.Info(&quot;DELETE /api/sheets/{fiat} - удаление всей таблицы&quot;)&#10;&#9;a.log.Info(&quot;DELETE /api/sheets/{fiat}/sheet/{sheetName} - удаление листа из таблицы&quot;)&#10;&#9;a.log.Info(&quot;GET /health - проверка состояния сервиса&quot;)&#10;&#10;&#9;return server.ListenAndServe()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/internal/services/sheetsControl/sheetsControl.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/internal/services/sheetsControl/sheetsControl.go" />
              <option name="originalContent" value="package sheetsControl&#10;&#10;import (&#10;&#9;&quot;GoogleSheetW/internal/apperrors&quot;&#10;&#9;&quot;GoogleSheetW/internal/cache&quot;&#10;&#9;&quot;GoogleSheetW/internal/logger&quot;&#10;&#9;&quot;GoogleSheetW/internal/models&quot;&#10;&#9;&quot;GoogleSheetW/internal/services/googleAPI&quot;&#10;&#9;&quot;GoogleSheetW/internal/settings&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;go.uber.org/zap&quot;&#10;&#9;&quot;google.golang.org/api/drive/v3&quot;&#10;&#9;&quot;google.golang.org/api/sheets/v4&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;func dataTime(nameList string) []*sheets.ValueRange {&#10;&#9;return []*sheets.ValueRange{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;%s!A1&quot;, nameList),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Дата записи:&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;%s!A2:B2&quot;, nameList),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Текущая дата&quot;, &quot;=NOW()- TIME(0, 0, 0)&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;%s!A3:B3&quot;, nameList),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Минут прошло&quot;, &quot;=IF(B1=\&quot;\&quot;, \&quot;\&quot;, ROUND((B2 - B1) * 1440,2))&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;func rawDataFilterFunc() []*sheets.ValueRange {&#10;&#9;return []*sheets.ValueRange{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: &quot;RAW_filter!A6&quot;,&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;=QUERY(RAW!$A4:O,\&quot;select A,B,C,D,E,F,G,H,I,J,K,L,M,N,O\&quot;)&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;func toInterface2D(data [][]string) [][]interface{} {&#10;&#9;result := make([][]interface{}, len(data))&#10;&#9;for i, row := range data {&#10;&#9;&#9;result[i] = make([]interface{}, len(row))&#10;&#9;&#9;for j := range row {&#10;&#9;&#9;&#9;result[i][j] = row[j]&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return result&#10;}&#10;&#10;func soupToSheet(soup models.Soup) []*sheets.ValueRange {&#10;&#9;return []*sheets.ValueRange{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A5&quot;, soup.Name),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Fixed Price:&quot;, soup.FixedPrice},&#10;&#9;&#9;&#9;&#9;{&quot;Best Price:&quot;, soup.BestPrice},&#10;&#9;&#9;&#9;&#9;{&quot;Best Price Link&quot;, soup.BestPriceLink},&#10;&#9;&#9;&#9;&#9;{&quot;Money Supply:&quot;, soup.MoneySupply},&#10;&#9;&#9;&#9;&#9;{&quot;Выборка из:&quot;, soup.AverageSize},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!B1&quot;, soup.Name),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{soup.Date},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A10&quot;, soup.Name),&#10;&#9;&#9;&#9;Values: func() [][]interface{} {&#10;&#9;&#9;&#9;&#9;var ans [][]interface{}&#10;&#9;&#9;&#9;&#9;for _, InfoFilter := range soup.InfoFilters {&#10;&#9;&#9;&#9;&#9;&#9;// Преобразуем массив банков в строку через запятую&#10;&#9;&#9;&#9;&#9;&#9;banksString := strings.Join(InfoFilter.BanksName, &quot;, &quot;)&#10;&#9;&#9;&#9;&#9;&#9;ans = append(ans,&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Биржа:&quot;, InfoFilter.Exchange},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Банки:&quot;, banksString},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Выполненных заказов&quot;, InfoFilter.MonthOrder},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Процент выполненных заказов&quot;, InfoFilter.MonthFinishRate},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Макс. минимальная сумма транзакции&quot;, InfoFilter.MaxLowSingleTransAmount},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Мин. максимальная сумма транзакции&quot;, InfoFilter.MinHighSingleTransAmount},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Размер выборки&quot;, InfoFilter.AverageSize},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;_______________&quot;, &quot;________________&quot;},&#10;&#9;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;ans = append(ans,&#10;&#9;&#9;&#9;&#9;&#9;[]interface{}{&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;Exchange:&quot;, &quot;Fiat&quot;, &quot;Asset&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;TradeType&quot;, &quot;NickName&quot;, &quot;Price&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;MonthOrderCount&quot;, &quot;MonthFinishRate&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;UserType&quot;, &quot;MaxSingleTransAmount&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;MinSingleTransAmount&quot;, &quot;LastQuantity&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;Link&quot;, &quot;PaymentMethod&quot;, &quot;monthFinishRate&quot;})&#10;&#9;&#9;&#9;&#9;ans = append(ans, toInterface2D(soup.Data)...)&#10;&#9;&#9;&#9;&#9;return ans&#10;&#9;&#9;&#9;}(),&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;}&#10;&#10;type SheetsControl struct {&#10;&#9;ctx      context.Context&#10;&#9;sheetSrv *sheets.Service&#10;&#9;driveSrv *drive.Service&#10;&#9;cache    cache.Cache&#10;&#9;log      *zap.SugaredLogger&#10;}&#10;&#10;func New(ctx context.Context, cache cache.Cache, pathToCredentialsFile string) *SheetsControl {&#10;&#9;log := logger.Get()&#10;&#9;cred, err := googleAPI.GetCredentials(ctx, pathToCredentialsFile)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;sheetSrv, err := googleAPI.GetSheetsService(ctx, cred)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;driveSrv, err := googleAPI.GetDriveService(ctx, cred)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;ans := SheetsControl{&#10;&#9;&#9;ctx:      ctx,&#10;&#9;&#9;sheetSrv: sheetSrv,&#10;&#9;&#9;driveSrv: driveSrv,&#10;&#9;&#9;cache:    cache,&#10;&#9;&#9;log:      log,&#10;&#9;}&#10;&#9;err = ans.update()&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;return &amp;ans&#10;}&#10;&#10;func (sc *SheetsControl) update() error {&#10;&#9;// Получаем карту с именами и ID всех таблиц&#10;&#9;sheetIDMap, err := googleAPI.GetAllSheetIDByName(sc.driveSrv)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка получения id таблиц: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// Добавляем информацию о таблицах в кэш&#10;&#9;err = sc.cache.AddToCash(sheetIDMap)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка инициализации кеша таблиц: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// Проходим по всем таблицам и получаем список листов для каждой&#10;&#9;for fiat, spreadsheetID := range sheetIDMap {&#10;&#9;&#9;// Получаем список всех листов в таблице&#10;&#9;&#9;spreadsheet, err := sc.sheetSrv.Spreadsheets.Get(spreadsheetID).Do()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;sc.log.Warnw(&quot;Ошибка получения списка листов для таблицы&quot;,&#10;&#9;&#9;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&#9;&#9;&quot;spreadsheetID&quot;, spreadsheetID,&#10;&#9;&#9;&#9;&#9;&quot;error&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Добавляем каждый лист в кэш&#10;&#9;&#9;for _, sheet := range spreadsheet.Sheets {&#10;&#9;&#9;&#9;sheetName := sheet.Properties.Title&#10;&#9;&#9;&#9;err = sc.cache.SetSupInCashed(fiat, sheetName)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Warnw(&quot;Ошибка добавления листа в кэш&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&#9;&#9;&#9;&quot;sheetName&quot;, sheetName,&#10;&#9;&#9;&#9;&#9;&#9;&quot;error&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;sc.log.Infow(&quot;Обновлены данные о листах в таблице&quot;,&#10;&#9;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&#9;&quot;sheets_count&quot;, len(spreadsheet.Sheets))&#10;&#9;}&#10;&#10;&#9;sc.log.Info(&quot;Кэш успешно обновлен&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (sc *SheetsControl) SetSheetData(data models.SheetData) error {&#10;&#9;sheetID, err := sc.cache.GetIDbyFiat(data.Fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;switch {&#10;&#9;&#9;case errors.As(err, &amp;apperrors.ErrCacheNotFound):&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_emails := settings.GetSettings().GetEmails()&#10;&#9;&#9;&#9;&#9;sheetID, err = googleAPI.CreateSheetWithPermission(sc.sheetSrv, sc.driveSrv, data.Fiat, &amp;_emails)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(&quot;Ошибка создания таблицы: &quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;err := sc.cache.SetIDbyFiat(data.Fiat, sheetID)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(&quot;Ошибка добавления  id таблицы в hash: &quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;break&#10;&#9;&#9;&#9;}&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(&quot;Неизвестная ошибка&quot;, err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;var ans []*sheets.ValueRange&#10;&#9;var delAns []string&#10;&#9;for _, soup := range data.SoupList {&#10;&#9;&#9;if ok, err := sc.cache.IsSupInCashed(data.Fiat, soup.Name); err == nil {&#10;&#9;&#9;&#9;if !ok {&#10;&#9;&#9;&#9;&#9;err := googleAPI.CreateSheetList(sc.sheetSrv, sheetID, soup.Name)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания листа для %s %s c ID %s &quot;, data.Fiat, soup.Name, sheetID), err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;err = sc.cache.SetSupInCashed(data.Fiat, soup.Name)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка добавление в cache название супа %s %s&quot;), data.Fiat, soup.Name)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;err = googleAPI.WriteToSheet(sc.sheetSrv, sheetID, dataTime(soup.Name))&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка записи данных в лист %s %s&quot;, data.Fiat, soup.Name), err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;ошибка чтения кэша %s %s&quot;, data.Fiat, soup.Name), err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;&#9;ans = append(ans, soupToSheet(soup)...)&#10;&#9;&#9;delAns = append(delAns, fmt.Sprintf(&quot;'%s'!A10:O100&quot;, soup.Name))&#10;&#9;}&#10;&#9;if ok, err := sc.cache.IsSupInCashed(data.Fiat, &quot;RAW&quot;); err == nil {&#10;&#9;&#9;if !ok {&#10;&#9;&#9;&#9;err := googleAPI.CreateSheetList(sc.sheetSrv, sheetID, &quot;RAW&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания листа для %s  %s c ID %s &quot;, data.Fiat, &quot;RAW&quot;, sheetID), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;err = googleAPI.CreateSheetList(sc.sheetSrv, sheetID, &quot;RAW_filter&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания листа для %s  %s c ID %s &quot;, data.Fiat, &quot;RAW_filter&quot;, sheetID), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;err = sc.cache.SetSupInCashed(data.Fiat, &quot;RAW&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка добавление в cache %s RAW&quot;), data.Fiat)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;err = googleAPI.WriteToSheet(sc.sheetSrv, sheetID, dataTime(&quot;RAW&quot;))&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка записи данных в лист %s %s&quot;, data.Fiat, &quot;RAW&quot;), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;idList, err := googleAPI.SheetIDByName(sc.sheetSrv, sheetID, &quot;RAW_filter&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка получения ID листа RAW_filter %s&quot;, data.Fiat), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;err = googleAPI.CreateSheetFilter(sc.sheetSrv, sheetID, idList, 0, 14, 5, 4500)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания фильтра в листе RAW_filter %s&quot;, data.Fiat), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;ans = append(ans, rawDataFilterFunc()...)&#10;&#9;&#9;}&#10;&#9;&#9;rawData := []*sheets.ValueRange{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;RAW!B1&quot;),&#10;&#9;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;&#9;{data.RAWData.Date},&#10;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;Range:  fmt.Sprintf(&quot;RAW!A4:Q4500&quot;),&#10;&#9;&#9;&#9;&#9;Values: toInterface2D(data.RAWData.Data),&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;ans = append(ans, rawData...)&#10;&#9;&#9;delAns = append(delAns, &quot;RAW!A4:Q4500&quot;)&#10;&#10;&#9;} else {&#10;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;ошибка чтения кэша %s RawData&quot;, data.Fiat), err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;err = googleAPI.DeleteFromSheet(sc.sheetSrv, sheetID, delAns)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка удаления данных в листе %s&quot;, data.Fiat), err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;err = googleAPI.WriteToSheet(sc.sheetSrv, sheetID, ans)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка записи данных в лист %s&quot;, data.Fiat), err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// DeleteSheet удаляет лист из таблицы&#10;func (sc *SheetsControl) DeleteSheet(fiat, sheetName string) error {&#10;&#9;sc.log.Infow(&quot;Удаление листа из таблицы&quot;,&#10;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&quot;sheet_name&quot;, sheetName)&#10;&#10;&#9;// Получаем ID таблицы из кэша&#10;&#9;sheetID, err := sc.cache.GetIDbyFiat(fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Таблица не найдена&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;таблица для %s не найдена: %v&quot;, fiat, err)&#10;&#9;}&#10;&#10;&#9;// Проверяем, что лист существует в кэше&#10;&#9;exists, err := sc.cache.IsSupInCashed(fiat, sheetName)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка проверки листа в кэше&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;ошибка проверки листа %s: %v&quot;, sheetName, err)&#10;&#9;}&#10;&#10;&#9;if !exists {&#10;&#9;&#9;sc.log.Warnw(&quot;Лист не найден в кэше&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName)&#10;&#9;&#9;return fmt.Errorf(&quot;лист %s не найден в таблице %s&quot;, sheetName, fiat)&#10;&#9;}&#10;&#10;&#9;// Удаляем лист через Google Sheets API&#10;&#9;err = googleAPI.DeleteSheetByName(sc.sheetSrv, sheetID, sheetName)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка удаления листа через API&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;не удалось удалить лист %s: %v&quot;, sheetName, err)&#10;&#9;}&#10;&#10;&#9;// Удаляем лист из кэша&#10;&#9;err = sc.cache.RemoveSupFromCashed(fiat, sheetName)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Warnw(&quot;Ошибка удаления листа из кэша&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName, &quot;error&quot;, err)&#10;&#9;&#9;// Не возвращаем ошибку, так как лист уже удален из Google Sheets&#10;&#9;}&#10;&#10;&#9;sc.log.Infow(&quot;Лист успешно удален&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName)&#10;&#9;return nil&#10;}&#10;&#10;// DeleteSpreadsheet удаляет всю таблицу&#10;func (sc *SheetsControl) DeleteSpreadsheet(fiat string) error {&#10;&#9;sc.log.Infow(&quot;Удаление таблицы&quot;,&#10;&#9;&#9;&quot;fiat&quot;, fiat)&#10;&#10;&#9;// Получаем ID таблицы из кэша&#10;&#9;sheetID, err := sc.cache.GetIDbyFiat(fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Таблица не найдена&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;таблица для %s не найдена: %v&quot;, fiat, err)&#10;&#9;}&#10;&#10;&#9;// Удаляем таблицу через Google Drive API&#10;&#9;err = googleAPI.DeleteSpreadsheetByID(sc.driveSrv, sheetID)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка удаления таблицы через API&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;не удалось удалить таблицу %s: %v&quot;, fiat, err)&#10;&#9;}&#10;&#10;&#9;// Удаляем валюту и все связанные листы из кэша&#10;&#9;err = sc.cache.RemoveFiatFromCache(fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Warnw(&quot;Ошибка удаления валюты из кэша&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;// Не возвращаем ошибку, так как таблица уже удалена из Google Drive&#10;&#9;}&#10;&#10;&#9;sc.log.Infow(&quot;Таблица успешно удалена&quot;, &quot;fiat&quot;, fiat)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package sheetsControl&#10;&#10;import (&#10;&#9;&quot;GoogleSheetW/internal/apperrors&quot;&#10;&#9;&quot;GoogleSheetW/internal/cache&quot;&#10;&#9;&quot;GoogleSheetW/internal/logger&quot;&#10;&#9;&quot;GoogleSheetW/internal/models&quot;&#10;&#9;&quot;GoogleSheetW/internal/services/googleAPI&quot;&#10;&#9;&quot;GoogleSheetW/internal/settings&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;go.uber.org/zap&quot;&#10;&#9;&quot;google.golang.org/api/drive/v3&quot;&#10;&#9;&quot;google.golang.org/api/sheets/v4&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;func dataTime(nameList string) []*sheets.ValueRange {&#10;&#9;return []*sheets.ValueRange{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A1&quot;, nameList),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Дата записи:&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A2:B2&quot;, nameList),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Текущая дата&quot;, &quot;=NOW()- TIME(0, 0, 0)&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A3:B3&quot;, nameList),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Минут прошло&quot;, &quot;=IF(B1=\&quot;\&quot;, \&quot;\&quot;, ROUND((B2 - B1) * 1440,2))&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;func rawDataFilterFunc() []*sheets.ValueRange {&#10;&#9;return []*sheets.ValueRange{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: &quot;RAW_filter!A6&quot;,&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;=QUERY(RAW!$A4:O,\&quot;select A,B,C,D,E,F,G,H,I,J,K,L,M,N,O\&quot;)&quot;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;func toInterface2D(data [][]string) [][]interface{} {&#10;&#9;result := make([][]interface{}, len(data))&#10;&#9;for i, row := range data {&#10;&#9;&#9;result[i] = make([]interface{}, len(row))&#10;&#9;&#9;for j := range row {&#10;&#9;&#9;&#9;result[i][j] = row[j]&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return result&#10;}&#10;&#10;func soupToSheet(soup models.Soup) []*sheets.ValueRange {&#10;&#9;return []*sheets.ValueRange{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A5&quot;, soup.Name),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{&quot;Fixed Price:&quot;, soup.FixedPrice},&#10;&#9;&#9;&#9;&#9;{&quot;Best Price:&quot;, soup.BestPrice},&#10;&#9;&#9;&#9;&#9;{&quot;Best Price Link&quot;, soup.BestPriceLink},&#10;&#9;&#9;&#9;&#9;{&quot;Money Supply:&quot;, soup.MoneySupply},&#10;&#9;&#9;&#9;&#9;{&quot;Выборка из:&quot;, soup.AverageSize},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!B1&quot;, soup.Name),&#10;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;{soup.Date},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;'%s'!A10&quot;, soup.Name),&#10;&#9;&#9;&#9;Values: func() [][]interface{} {&#10;&#9;&#9;&#9;&#9;var ans [][]interface{}&#10;&#9;&#9;&#9;&#9;for _, InfoFilter := range soup.InfoFilters {&#10;&#9;&#9;&#9;&#9;&#9;// Преобразуем массив банков в строку через запятую&#10;&#9;&#9;&#9;&#9;&#9;banksString := strings.Join(InfoFilter.BanksName, &quot;, &quot;)&#10;&#9;&#9;&#9;&#9;&#9;ans = append(ans,&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Биржа:&quot;, InfoFilter.Exchange},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Банки:&quot;, banksString},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Выполненных заказов&quot;, InfoFilter.MonthOrder},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Процент выполненных заказов&quot;, InfoFilter.MonthFinishRate},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Макс. минимальная сумма транзакции&quot;, InfoFilter.MaxLowSingleTransAmount},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Мин. максимальная сумма транзакции&quot;, InfoFilter.MinHighSingleTransAmount},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;Размер выборки&quot;, InfoFilter.AverageSize},&#10;&#9;&#9;&#9;&#9;&#9;&#9;[]interface{}{&quot;_______________&quot;, &quot;________________&quot;},&#10;&#9;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;ans = append(ans,&#10;&#9;&#9;&#9;&#9;&#9;[]interface{}{&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;Exchange:&quot;, &quot;Fiat&quot;, &quot;Asset&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;TradeType&quot;, &quot;NickName&quot;, &quot;Price&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;MonthOrderCount&quot;, &quot;MonthFinishRate&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;UserType&quot;, &quot;MaxSingleTransAmount&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;MinSingleTransAmount&quot;, &quot;LastQuantity&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;Link&quot;, &quot;PaymentMethod&quot;, &quot;monthFinishRate&quot;})&#10;&#9;&#9;&#9;&#9;ans = append(ans, toInterface2D(soup.Data)...)&#10;&#9;&#9;&#9;&#9;return ans&#10;&#9;&#9;&#9;}(),&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;}&#10;&#10;type SheetsControl struct {&#10;&#9;ctx      context.Context&#10;&#9;sheetSrv *sheets.Service&#10;&#9;driveSrv *drive.Service&#10;&#9;cache    cache.Cache&#10;&#9;log      *zap.SugaredLogger&#10;}&#10;&#10;func New(ctx context.Context, cache cache.Cache, pathToCredentialsFile string) *SheetsControl {&#10;&#9;log := logger.Get()&#10;&#9;cred, err := googleAPI.GetCredentials(ctx, pathToCredentialsFile)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;sheetSrv, err := googleAPI.GetSheetsService(ctx, cred)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;driveSrv, err := googleAPI.GetDriveService(ctx, cred)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;ans := SheetsControl{&#10;&#9;&#9;ctx:      ctx,&#10;&#9;&#9;sheetSrv: sheetSrv,&#10;&#9;&#9;driveSrv: driveSrv,&#10;&#9;&#9;cache:    cache,&#10;&#9;&#9;log:      log,&#10;&#9;}&#10;&#9;err = ans.update()&#10;&#9;if err != nil {&#10;&#9;&#9;log.Errorw(&quot;Ошибка создания SheetsControl: &quot;, err)&#10;&#9;&#9;panic(err)&#10;&#9;}&#10;&#9;return &amp;ans&#10;}&#10;&#10;func (sc *SheetsControl) update() error {&#10;&#9;// Получаем карту с именами и ID всех таблиц&#10;&#9;sheetIDMap, err := googleAPI.GetAllSheetIDByName(sc.driveSrv)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка получения id таблиц: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// Добавляем информацию о таблицах в кэш&#10;&#9;err = sc.cache.AddToCash(sheetIDMap)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка инициализации кеша таблиц: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// Проходим по всем таблицам и получаем список листов для каждой&#10;&#9;for fiat, spreadsheetID := range sheetIDMap {&#10;&#9;&#9;// Получаем список всех листов в таблице&#10;&#9;&#9;spreadsheet, err := sc.sheetSrv.Spreadsheets.Get(spreadsheetID).Do()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;sc.log.Warnw(&quot;Ошибка получения списка листов для таблицы&quot;,&#10;&#9;&#9;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&#9;&#9;&quot;spreadsheetID&quot;, spreadsheetID,&#10;&#9;&#9;&#9;&#9;&quot;error&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Добавляем каждый лист в кэш&#10;&#9;&#9;for _, sheet := range spreadsheet.Sheets {&#10;&#9;&#9;&#9;sheetName := sheet.Properties.Title&#10;&#9;&#9;&#9;err = sc.cache.SetSupInCashed(fiat, sheetName)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Warnw(&quot;Ошибка добавления листа в кэш&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&#9;&#9;&#9;&quot;sheetName&quot;, sheetName,&#10;&#9;&#9;&#9;&#9;&#9;&quot;error&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;sc.log.Infow(&quot;Обновлены данные о листах в таблице&quot;,&#10;&#9;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&#9;&quot;sheets_count&quot;, len(spreadsheet.Sheets))&#10;&#9;}&#10;&#10;&#9;sc.log.Info(&quot;Кэш успешно обновлен&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (sc *SheetsControl) SetSheetData(data models.SheetData) error {&#10;&#9;sheetID, err := sc.cache.GetIDbyFiat(data.Fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;switch {&#10;&#9;&#9;case errors.As(err, &amp;apperrors.ErrCacheNotFound):&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_emails := settings.GetSettings().GetEmails()&#10;&#9;&#9;&#9;&#9;sheetID, err = googleAPI.CreateSheetWithPermission(sc.sheetSrv, sc.driveSrv, data.Fiat, &amp;_emails)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(&quot;Ошибка создания таблицы: &quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;err := sc.cache.SetIDbyFiat(data.Fiat, sheetID)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(&quot;Ошибка добавления  id таблицы в hash: &quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;break&#10;&#9;&#9;&#9;}&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(&quot;Неизвестная ошибка&quot;, err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;var ans []*sheets.ValueRange&#10;&#9;var delAns []string&#10;&#9;for _, soup := range data.SoupList {&#10;&#9;&#9;if ok, err := sc.cache.IsSupInCashed(data.Fiat, soup.Name); err == nil {&#10;&#9;&#9;&#9;if !ok {&#10;&#9;&#9;&#9;&#9;err := googleAPI.CreateSheetList(sc.sheetSrv, sheetID, soup.Name)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания листа для %s %s c ID %s &quot;, data.Fiat, soup.Name, sheetID), err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;err = sc.cache.SetSupInCashed(data.Fiat, soup.Name)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка добавление в cache название супа %s %s&quot;), data.Fiat, soup.Name)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;err = googleAPI.WriteToSheet(sc.sheetSrv, sheetID, dataTime(soup.Name))&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка записи данных в лист %s %s&quot;, data.Fiat, soup.Name), err)&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;ошибка чтения кэша %s %s&quot;, data.Fiat, soup.Name), err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;&#9;ans = append(ans, soupToSheet(soup)...)&#10;&#9;&#9;delAns = append(delAns, fmt.Sprintf(&quot;'%s'!A10:O100&quot;, soup.Name))&#10;&#9;}&#10;&#9;if ok, err := sc.cache.IsSupInCashed(data.Fiat, &quot;RAW&quot;); err == nil {&#10;&#9;&#9;if !ok {&#10;&#9;&#9;&#9;err := googleAPI.CreateSheetList(sc.sheetSrv, sheetID, &quot;RAW&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания листа для %s  %s c ID %s &quot;, data.Fiat, &quot;RAW&quot;, sheetID), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;err = googleAPI.CreateSheetList(sc.sheetSrv, sheetID, &quot;RAW_filter&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания листа для %s  %s c ID %s &quot;, data.Fiat, &quot;RAW_filter&quot;, sheetID), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;err = sc.cache.SetSupInCashed(data.Fiat, &quot;RAW&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка добавление в cache %s RAW&quot;), data.Fiat)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;err = googleAPI.WriteToSheet(sc.sheetSrv, sheetID, dataTime(&quot;RAW&quot;))&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка записи данных в лист %s %s&quot;, data.Fiat, &quot;RAW&quot;), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;idList, err := googleAPI.SheetIDByName(sc.sheetSrv, sheetID, &quot;RAW_filter&quot;)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка получения ID листа RAW_filter %s&quot;, data.Fiat), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;err = googleAPI.CreateSheetFilter(sc.sheetSrv, sheetID, idList, 0, 14, 5, 4500)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка создания фильтра в листе RAW_filter %s&quot;, data.Fiat), err)&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;ans = append(ans, rawDataFilterFunc()...)&#10;&#9;&#9;}&#10;&#9;&#9;rawData := []*sheets.ValueRange{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;Range: fmt.Sprintf(&quot;RAW!B1&quot;),&#10;&#9;&#9;&#9;&#9;Values: [][]interface{}{&#10;&#9;&#9;&#9;&#9;&#9;{data.RAWData.Date},&#10;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;Range:  fmt.Sprintf(&quot;RAW!A4:Q4500&quot;),&#10;&#9;&#9;&#9;&#9;Values: toInterface2D(data.RAWData.Data),&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;ans = append(ans, rawData...)&#10;&#9;&#9;delAns = append(delAns, &quot;RAW!A4:Q4500&quot;)&#10;&#10;&#9;} else {&#10;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;ошибка чтения кэша %s RawData&quot;, data.Fiat), err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;err = googleAPI.DeleteFromSheet(sc.sheetSrv, sheetID, delAns)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка удаления данных в листе %s&quot;, data.Fiat), err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;err = googleAPI.WriteToSheet(sc.sheetSrv, sheetID, ans)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(fmt.Sprintf(&quot;Ошибка записи данных в лист %s&quot;, data.Fiat), err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// DeleteSheet удаляет лист из таблицы&#10;func (sc *SheetsControl) DeleteSheet(fiat, sheetName string) error {&#10;&#9;sc.log.Infow(&quot;Удаление листа из таблицы&quot;,&#10;&#9;&#9;&quot;fiat&quot;, fiat,&#10;&#9;&#9;&quot;sheet_name&quot;, sheetName)&#10;&#10;&#9;// Получаем ID таблицы из кэша&#10;&#9;sheetID, err := sc.cache.GetIDbyFiat(fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Таблица не найдена&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;таблица для %s не найдена: %v&quot;, fiat, err)&#10;&#9;}&#10;&#10;&#9;// Проверяем, что лист существует в кэше&#10;&#9;exists, err := sc.cache.IsSupInCashed(fiat, sheetName)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка проверки листа в кэше&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;ошибка проверки листа %s: %v&quot;, sheetName, err)&#10;&#9;}&#10;&#10;&#9;if !exists {&#10;&#9;&#9;sc.log.Warnw(&quot;Лист не найден в кэше&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName)&#10;&#9;&#9;return fmt.Errorf(&quot;лист %s не найден в таблице %s&quot;, sheetName, fiat)&#10;&#9;}&#10;&#10;&#9;// Удаляем лист через Google Sheets API&#10;&#9;err = googleAPI.DeleteSheetByName(sc.sheetSrv, sheetID, sheetName)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка удаления листа через API&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;не удалось удалить лист %s: %v&quot;, sheetName, err)&#10;&#9;}&#10;&#10;&#9;// Удаляем лист из кэша&#10;&#9;err = sc.cache.RemoveSupFromCashed(fiat, sheetName)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Warnw(&quot;Ошибка удаления листа из кэша&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName, &quot;error&quot;, err)&#10;&#9;&#9;// Не возвращаем ошибку, так как лист уже удален из Google Sheets&#10;&#9;}&#10;&#10;&#9;sc.log.Infow(&quot;Лист успешно удален&quot;, &quot;fiat&quot;, fiat, &quot;sheet_name&quot;, sheetName)&#10;&#9;return nil&#10;}&#10;&#10;// DeleteSpreadsheet удаляет всю таблицу&#10;func (sc *SheetsControl) DeleteSpreadsheet(fiat string) error {&#10;&#9;sc.log.Infow(&quot;Удаление таблицы&quot;,&#10;&#9;&#9;&quot;fiat&quot;, fiat)&#10;&#10;&#9;// Получаем ID таблицы из кэша&#10;&#9;sheetID, err := sc.cache.GetIDbyFiat(fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Таблица не найдена&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;таблица для %s не найдена: %v&quot;, fiat, err)&#10;&#9;}&#10;&#10;&#9;// Удаляем таблицу через Google Drive API&#10;&#9;err = googleAPI.DeleteSpreadsheetByID(sc.driveSrv, sheetID)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Errorw(&quot;Ошибка удаления таблицы через API&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;не удалось удалить таблицу %s: %v&quot;, fiat, err)&#10;&#9;}&#10;&#10;&#9;// Удаляем валюту и все связанные листы из кэша&#10;&#9;err = sc.cache.RemoveFiatFromCache(fiat)&#10;&#9;if err != nil {&#10;&#9;&#9;sc.log.Warnw(&quot;Ошибка удаления валюты из кэша&quot;, &quot;fiat&quot;, fiat, &quot;error&quot;, err)&#10;&#9;&#9;// Не возвращаем ошибку, так как таблица уже удалена из Google Drive&#10;&#9;}&#10;&#10;&#9;sc.log.Infow(&quot;Таблица успешно удалена&quot;, &quot;fiat&quot;, fiat)&#10;&#9;return nil&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>